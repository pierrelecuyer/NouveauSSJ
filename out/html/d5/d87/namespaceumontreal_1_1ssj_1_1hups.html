<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Package umontreal.ssj.hups</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>umontreal</b></li><li class="navelem"><b>ssj</b></li><li class="navelem"><a class="el" href="../../d5/d87/namespaceumontreal_1_1ssj_1_1hups.html">hups</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Package umontreal.ssj.hups</div>  </div>
</div><!--header-->
<div class="contents">

<p>Highly Uniform Point Sets.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d3d/classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">AntitheticPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class provides antithetic versions of the contained points.  <a href="../../dc/d3d/classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d5e/classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html">BakerTransformedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class embodies a point set to which a <em>baker's transformation</em> (also called a <em>tent transform</em>) is applied (see, e.g., <b>[rDIC10a]</b>, <b>[vHIC02a]</b>, <b>[vLEC09f]</b>).  <a href="../../db/d5e/classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d86/classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">CachedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class caches a point set by precomputing and storing its points locally in an array.  <a href="../../df/d86/classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d02/classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">ContainerPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This acts as a generic base class for all <em>container classes</em> that contain a point set and apply a specific kind of transformation to the coordinates \(u_{i,j}\) when the points are generated by the iterator.  <a href="../../d4/d02/classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/dcc/classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html">CycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear feedback shift register (LFSR) random number generators <b>[rLEC96a]</b>, <b>[vLEC99a]</b>, <b>[rNIE92b]</b>, produce numbers by generating a sequence of bits from a linear recurrence modulo 2, and forming fractional numbers by taking blocks of successive bits.  <a href="../../df/dcc/classumontreal_1_1ssj_1_1hups_1_1CycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d45/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class provides the basic structures for storing and manipulating a point set defined by a set of cycles.  <a href="../../d4/d45/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d58/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">CycleBasedPointSetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="../../d4/d45/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a>, except that the successive values in the cycles are stored as integers in the range \(\{0,\dots,2^k-1\}\), where \(1\le k \le31\).  <a href="../../de/d58/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the basic structures for storing and manipulating <em>linear digital nets in base \(b\)</em>, for an arbitrary base \(b\ge2\).  <a href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd5/classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">DigitalNetBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special case of <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> for the base \(b=2\).  <a href="../../d3/dd5/classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d25/classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html">DigitalNetBase2FromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class permits one to read the parameters that define a digital net <em>in base 2</em> either from a file, or from a URL address.  <a href="../../df/d25/classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2FromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d86/classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html">DigitalNetFromFile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows us to read the parameters defining a digital net either from a file, or from a URL address on the World Wide Web.  <a href="../../de/d86/classumontreal_1_1ssj_1_1hups_1_1DigitalNetFromFile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0d/classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">DigitalSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences.  <a href="../../dd/d0d/classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dec/classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html">DigitalSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class describes methods specific to digital sequences in base 2.  <a href="../../d6/dec/classumontreal_1_1ssj_1_1hups_1_1DigitalSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de8/classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html">EmptyRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an empty <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="../../d8/de8/classumontreal_1_1ssj_1_1hups_1_1EmptyRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dce/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">F2wCycleBasedLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear feedback shift register sequence.  <a href="../../d3/dce/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d76/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">F2wCycleBasedPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class creates a point set based upon a linear congruential sequence in the finite field \(\mathbb F_{2^w}[z]/P(z)\).  <a href="../../dd/d76/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d86/classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">F2wNetLFSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a linear feedback shift register generator.  <a href="../../d1/d86/classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d8c/classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">F2wNetPolyLCG</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a digital net in base 2 starting from a polynomial LCG in \(\mathbb F_{2^w}[z]/P(z)\).  <a href="../../de/d8c/classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d77/classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html">F2wStructure</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements methods and fields needed by the classes <a class="el" href="../../d1/d86/classumontreal_1_1ssj_1_1hups_1_1F2wNetLFSR.html">umontreal.ssj.hups.F2wNetLFSR</a>, <a class="el" href="../../de/d8c/classumontreal_1_1ssj_1_1hups_1_1F2wNetPolyLCG.html">umontreal.ssj.hups.F2wNetPolyLCG</a>, <a class="el" href="../../d3/dce/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedLFSR.html">umontreal.ssj.hups.F2wCycleBasedLFSR</a> and <a class="el" href="../../dd/d76/classumontreal_1_1ssj_1_1hups_1_1F2wCycleBasedPolyLCG.html">umontreal.ssj.hups.F2wCycleBasedPolyLCG</a>.  <a href="../../d0/d77/classumontreal_1_1ssj_1_1hups_1_1F2wStructure.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d22/classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html">FaureSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets or digital sequences formed by the first \(n = b^k\) points of the Faure sequence in base \(b\).  <a href="../../d2/d22/classumontreal_1_1ssj_1_1hups_1_1FaureSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc6/classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html">HaltonSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the sequence of Halton <b>[rHAL60a]</b>&thinsp;, which is essentially a modification of Hammersley nets for producing an infinite sequence of points having low discrepancy.  <a href="../../d2/dc6/classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d05/classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html">HammersleyPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>Hammersley point sets</em>, which are defined as follows.  <a href="../../d4/d05/classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d8b/classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html">IndependentPointsCached</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to IndependentPoints, but the points are all generated and stored (cached) when the point set is randomized.  <a href="../../d4/d8b/classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d26/classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html">KorobovLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <em>Korobov lattice</em>, which represents the same point set as in class <a class="el" href="../../da/d7a/classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a>, but implemented differently.  <a href="../../dd/d26/classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d22/classumontreal_1_1ssj_1_1hups_1_1KorobovLatticeSequence.html">KorobovLatticeSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d02/classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html">LatinHypercube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements Latin Hypercube Sampling (LHS) with \(n\) points in the \(s\)-dimensional unit hypercube.  <a href="../../dc/d02/classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7a/classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a recurrence-based point set defined via a linear congruential recurrence of the form \(x_i = a x_{i-1} \mod n\) and \(u_i = x_i / n\).  <a href="../../da/d7a/classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d27/classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html">LMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a left matrix scrambling and adds a random digital shift.  <a href="../../d0/d27/classumontreal_1_1ssj_1_1hups_1_1LMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d42/classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html">NestedUniformScrambling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is for a randomization that can be used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a> that performs Owen's nested uniform scrambling <b>[vOWE95a]</b>, <b>[vOWE03a]</b> .  <a href="../../d4/d42/classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d02/classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html">NiedSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences constructed from the Niederreiter sequence in base 2.  <a href="../../d0/d02/classumontreal_1_1ssj_1_1hups_1_1NiedSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dcc/classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html">NiedXingSequenceBase2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital sequences based on the Niederreiter-Xing sequence in base 2.  <a href="../../db/dcc/classumontreal_1_1ssj_1_1hups_1_1NiedXingSequenceBase2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d88/classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">PaddedPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class realizes <em>padded point sets</em>, constructed by taking some coordinates from a point set \(P_1\), other coordinates from a point set \(P_2\), and so on.  <a href="../../d4/d88/classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html">PointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class represents a general point set.  <a href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d29/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">PointSetIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface for <em>iterators</em> that permit one to go through the points of a #PointSet and the successive coordinates of these points.  <a href="../../d7/d29/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface is for a <em>randomization</em> that can be used to randomize a <a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>.  <a href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7f/classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html">RadicalInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements basic methods for working with radical inverses of integers in an arbitrary basis \(b\).  <a href="../../dd/d7f/classumontreal_1_1ssj_1_1hups_1_1RadicalInverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/db7/classumontreal_1_1ssj_1_1hups_1_1RandomShift.html">RandomShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a>.  <a href="../../dc/db7/classumontreal_1_1ssj_1_1hups_1_1RandomShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d23/classumontreal_1_1ssj_1_1hups_1_1RandomStart.html">RandomStart</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that randomizes a sequence simply by taking a random starting point.  <a href="../../d6/d23/classumontreal_1_1ssj_1_1hups_1_1RandomStart.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/df7/classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html">RandShiftedMod1PointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class embodies an arbitrary point set and its iterator adds a random shift modulo 1 to all the points, when producing the coordinates.  <a href="../../db/df7/classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d94/classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements point sets specified by integration lattices of rank.  <a href="../../d4/d94/classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7b/classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html">RQMCPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used for <em>randomized quasi-Monte Carlo</em> (RQMC) simulations <b>[vLEC00b]</b>, <b>[vLEC02a]</b>, <b>[vOWE97a]</b>, <b>[vOWE97b]</b>.  <a href="../../dd/d7b/classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9e/classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html">SMScrambleShift</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> that performs a striped matrix scrambling <b>[vOWE03a]</b> and adds a random digital shift.  <a href="../../d6/d9e/classumontreal_1_1ssj_1_1hups_1_1SMScrambleShift.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/ddf/classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html">SobolSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements digital nets and digital sequences in base 2 formed by the first \(n = 2^k\) points of a Sobol’ sequence <b>[rSOB67a]</b>, <b>[rSOB76b]</b>.  <a href="../../d6/ddf/classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dab/classumontreal_1_1ssj_1_1hups_1_1SortedAndCutPointSet.html">SortedAndCutPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is useful for the Array-RQMC method, in the situation where the Markov chain has a multidimensional state, the RQMC points are sorted once for all, based on their first \(\ell\) coordinates, then these coordinates are removed and only the remaining coordinates are kept and randomized at each step.  <a href="../../de/dab/classumontreal_1_1ssj_1_1hups_1_1SortedAndCutPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dcf/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation.  <a href="../../d2/dcf/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d9b/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html">StratifiedUnitCubeAnti</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a stratification of the unit cube in rectangular boxes of same size and orientation, similar to <a class="el" href="../../d2/dcf/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">StratifiedUnitCube</a>.  <a href="../../d6/d9b/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCubeAnti.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d1f/classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">SubsetOfPointSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This container class permits one to select a subset of a point set.  <a href="../../d9/d1f/classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Highly Uniform Point Sets. </p>
<h2>Monte Carlo and quasi-Monte Carlo</h2>
<p>This package provides classes implementing <em>highly uniform point sets</em> (HUPS) over the \(s\)-dimensional unit hypercube \([0,1)^s\), and tools for their randomization. The terminology <em>low-discrepancy sequence</em> (LDS) is often used for infinite sequences of points such that the <em>discrepancy</em> between the distribution of the first \(n\) points of the sequence and the uniform distribution converges to zero at a certain rate when \(n\to\infty\) <b>[rNIE92b]</b>. HUPS and LDS are used for quasi-Monte Carlo integration, as we now briefly explain. For more details, see <b>[rDIC10a]</b>, <b>[fGLA04a]</b>, <b>[rHEL98a]</b>, <b>[vLEC02a]</b>, <b>[vLEC03b]</b>, <b>[vLEC09f]</b>, <b>[vOWE98a]</b>, <b>[rNIE92b]</b>, <b>[rNUY14a]</b>, <b>[vSLO94a]</b>; for example. A short applied tutorial can be found in <b>[vLEC18a]</b>.</p>
<p>Suppose we want to estimate the integral of a function \(f\) defined over the \(s\)-dimensional unit hypercube, <a class="anchor" id="REF_hups_overview_eq_mu"></a> </p><p class="formulaDsp">
\[ \mu= \int_{[0,1)^s} f(\mathbf{u}) d\mathbf{u}. \tag{mu} \]
</p>
<p> Practically any mathematical expectation that can be estimated by simulation can be written in this way, usually for a very complicated \(f\) and sometimes for \(s=\infty\). Indeed, the source of randomness of stochastic simulations is usually a <em>stream</em> of real numbers \(\mathbf{u}= (u_0,u_1,u_2,…)\) whose purpose is to imitate i.i.d. \(U(0,1)\) random variables. These real numbers are transformed in complicated ways to produce the estimator. Thus, the dimension \(s\) of the integral in (<a class="el" href="../../d5/d87/namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_mu">mu</a>) represents the number of calls to the uniform random number generator if that number is deterministic. If it is random and unbounded, we take \(s = \infty\). In the latter case, we shall assume that the <em>actual</em> number of calls is finite with probability one (otherwise the simulation may never end).</p>
<p>We consider an estimator of \(\mu\) of the form <a class="anchor" id="REF_hups_overview_eq_Qn"></a> </p><p class="formulaDsp">
\[ Q_n = \frac{1}{n} \sum_{i=0}^{n-1} f(\mathbf{u}_i), \tag{Qn} \]
</p>
<p> which is the average of \(f\) over the <em>point set</em> \(P_n = \{\mathbf{u}_0,…,\mathbf{u}_{n-1}\} \subset[0,1)^s\). With the <em>Monte Carlo</em> (MC) method, the \(\mathbf{u}_i\)’s are i.i.d. random vectors uniformly distributed over \([0,1)^s\). Then, \(Q_n\) is an unbiased estimator of \(\mu\) with variance \(\sigma^2/n\), where </p><p class="formulaDsp">
\[ \sigma^2 = \int_{[0,1)^s} f^2(\mathbf{u}) d\mathbf{u}- \mu^2, \]
</p>
<p> and it obeys a central-limit theorem if \(\sigma^2 &lt; \infty\).</p>
<p><em>Quasi-Monte Carlo</em> (QMC) methods use point sets \(P_n\) that are <em>more evenly distributed</em> over the unit hypercube than typical random points. We call them <em>highly uniform point sets</em> (HUPS) or <em>QMC point sets</em>. The aim is to reduce the size of the integration error \(Q_n - \mu\). Among the most important classes of methods for constructing such point sets, we find are <em>digital nets</em>, <em>integration lattices in the real space</em>, <em>polynomial integration lattices</em>, <em>Hammersley points</em>, <em>Halton sequences</em>, etc.; see <b>[rDIC10a]</b>, <b>[vLEC02a]</b>, <b>[18a]</b>, <b>[rNIE92b]</b>, <b>[vSLO94a]</b>. All the methods named above are implemented in this package, in various flavors.</p>
<p>The deterministic QMC points can also be randomized in a way that each point has the uniform distribution in the unit cube while the point set as a whole keeps its high uniformity. This gives rise to randomized QMC (RQMC), which provides an unbiased estimator of \(\mu\) whose variance can be estimated via independent replications. This is further discussed below.</p>
<h2>Elementary constructions</h2>
<p>To give an idea of how HUPS and LDS can be constructed, we start with a simple one-dimensional example. If \(s=1\) and \(n\) is fixed, very simple highly uniform constructions are the point sets \(P_n = \{0,  1/n, …, (n-1)/n\}\) and the shifted version \(P’_n = \{1/(2n),  3/(2n),  …, (2n-1)/(2n)\}\).</p>
<p>In \(s &gt; 1\) dimensions, the simplest extensions would be as follows. Let \(n = d^s\) for some integer \(d\) and define \(P_n\) as the Cartesian product of \(s\) copies of the one-dimensional sets \(P_d\); that is, \(P_n = \{(u_0,…,u_{s-1}) : u_j \in\{0,  1/d,  …, (d-1)/d\}\) for each \(j\}\), and similarly for \(P’_n\). The point sets thus obtained are regular rectangular grids. Unfortunately, this approach breaks down rapidly when \(s\) gets large, because \(n\) must increase exponentially fast with \(s\) for fixed \(d\). Another important drawback is that when \(P_n\) is projected over lower-dimensional subspaces, several points are projected onto each other and become redundant <b>[vLEC02a]</b>.</p>
<p>A better idea is to construct a point set \(P_n\) in \(s\) dimensions such that each one-dimensional projection of \(P_n\) is the set of values \(\{0,  1/n,  …, (n-1)/n\}\). Of course, these values should not be visited in the same order for all coordinates, because otherwise all the points would lie on the diagonal line going from \((0,…,0)\) to \((1,…,1)\). In other words, for each coordinate \(j\), \(0\le j &lt; s\), we must define a different <em>permutation</em> of the integers \(\{0,…,n-1\}\) and visit the values \(\{0,  1/n,  …, (n-1)/n\}\) in the order determined by that permutation. The trick is to select those permutations in a way that \(P_n\) itself is highly uniform over \([0,1)^s\) in a well-defined sense (there are many ways to define it). This is what most construction methods attempt to achieve. Before looking at concrete ways of defining such permutations, we introduce a related issue: what to do if \(n\) is not fixed.</p>
<p>For \(s=1\), a simple way of filling up the unit interval \([0,1)\) uniformly is via the low-discrepancy sequence 0, 1/2, 1/4, 3/4, 1/8, 5/8, 3/8, 7/8, 1/16, 9/16, …, called the <em>van der Corput sequence</em> in base 2. More generally, select an integer \(b \ge2\), called the <em>base</em>. The <em>radical inverse</em> function in base \(b\), \(\psi_b : \mathbb{N}\to[0,1)\), is defined as follows. If \(i\) is a \(k\)-digit integer in base \(b\) with digital \(b\)-ary expansion </p><p class="formulaDsp">
\[ i = a_0 + a_1 b + …+ a_{k-1} b^{k-1}, \]
</p>
<p> then </p><p class="formulaDsp">
\[ \psi_b(i) = a_0 b^{-1} + a_1 b^{-2} + \cdots+ a_{k-1} b^{-k}. \]
</p>
<p> For a given \(b\), \(\psi_b(0), \psi_b(1), \psi_b(2), …\) is called the <em>van der Corput sequence in base \(b\)</em>. This sequence fills up the unit interval \([0,1)\) quite uniformly. For example, for \(b=2\) we obtain the sequence mentioned above and for \(b=3\) we obtain 0, 1/3, 2/3, 1/9, 4/9, 7/9, 2/9, 5/9, 8/9, 1/27, 10/27, 19/27, …. Moreover, for two relatively prime bases \(b_1\) and \(b_2\), the two sequences have no value in common except 0.</p>
<p>For \(s &gt; 1\), one could either take different (relatively prime) bases for the different coordinates, or take the same basis \(b\) but permute the successive values using a different permutation for each coordinate. These permutations are usually selected in a way that for every integer \(k\), the first \(b^k\) values that are enumerated remain the same (they are the values of \(\psi_b(i)\) for \(i=0,…,b^k-1\)), but they are enumerated in a different order. Several digital net constructions (to be defined later) fit this framework.</p>
<p>If we decide to take different bases, the most natural choice is to take the \(j\)th smallest prime, \(b_j\), as a base for coordinate \(j-1\); that is, base 2 for coordinate 0, base 3 for coordinate 1, base 5 for coordinate 2, and so on. The infinite sequence thus defined, where point \(i\) is <a class="anchor" id="REF_hups_overview_eq_Halton_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_s}(i)) \tag{Halton-point} \]
</p>
<p> for \(i \ge0\), was proposed in <b>[rHAL60a]</b>&thinsp; and is called the <em>Halton sequence</em>. One drawback of this sequence is that for large \(s\), the base \(b_s\) becomes quite large.</p>
<p>In the case where \(n\) is fixed, we can always take \(i/n\) as the first coordinate of point \(i\). In particular, the <em>Hammersley point set</em> with \(n\) points in \(s\) dimensions contains the points <a class="anchor" id="REF_hups_overview_eq_Hammersley_point"></a> </p><p class="formulaDsp">
\[ \mathbf{u}_i = (i/n,\psi_{b_1}(i),\psi_{b_2}(i),…, \psi_{b_{s-1}}(i)), \tag{Hammersley-point} \]
</p>
<p> for \(i=0,…,n-1\) <b>[rHAM60a]</b>&thinsp;. Historically, Halton sequences were defined as extensions of Hammersley point sets. Hammersley points and Halton sequences are implemented in the classes <a class="el" href="../../d4/d05/classumontreal_1_1ssj_1_1hups_1_1HammersleyPointSet.html">HammersleyPointSet</a> and <a class="el" href="../../d2/dc6/classumontreal_1_1ssj_1_1hups_1_1HaltonSequence.html">HaltonSequence</a>.</p>
<h2>Digital nets</h2>
<p><em>Digital nets and sequences</em> are an important class of HUPS and LDS constructions. Most concrete implementations, e.g., those proposed by Sobol’, Faure, Niederreiter, Niederreiter and Xing, Dick, etc., are <em>linear</em> digital nets and sequences, defined as follows (see also <b>[rDIC10a]</b>, <b>[vLEC02a]</b>, <b>[rNIE92b]</b>, <b>[rTEZ95a]</b>).</p>
<p>Let \(b\ge2\) be an arbitrary integer (usually a prime number), called the <em>base</em>. A net that contains \(n = b^k\) points in \(s\) dimensions is defined via \(s\) <em>generator matrices</em> \(\mathbf{C}_0,…,\mathbf{C}_{s-1}\), which are (in theory) \(\infty\times k\) matrices whose elements are in \(\mathbb{Z}_b = \{0,\dots,b-1\}\). The matrix \(\mathbf{C}_j\) is used for coordinate \(j\) of all the points, for \(j\ge0\). To define the \(i\)th point \(\mathbf{u}_i\), for \(i=0,…,b^k-1\), write the digital expansion of \(i\) in base \(b\) and multiply the vector of its digits by \(\mathbf{C}_j\) to obtain the digits of the expansion of \(u_{i,j}\), the \(j\)th coordinate of \(\mathbf{u}_i\). That is, <a class="anchor" id="REF_hups_overview_eq_digital_i"></a><a class="anchor" id="REF_hups_overview_eq_digital_Cj"></a><a class="anchor" id="REF_hups_overview_eq_digital_uij"></a><a class="anchor" id="REF_hups_overview_eq_digital_ui"></a> </p><p class="formulaDsp">
\begin{align} i &amp; = \sum_{\ell=0}^{k-1} a_{i,\ell} b^{\ell}, \tag{digital-i} \\ \begin{pmatrix} u_{i,j,1} \\ u_{i,j,2} \\ \vdots \end{pmatrix} &amp; = \mathbf{C}_j \begin{pmatrix} a_{i,0} \\ a_{i,1} \\ \vdots \\ a_{i,k-1} \end{pmatrix} , \tag{digital-Cj} \\ u_{i,j} &amp; = \sum_{\ell=1}^{\infty}u_{i,j,\ell} b^{-\ell}, \tag{digital-uij} \\ \mathbf{u}_i &amp; = (u_{i,0},…,u_{i,s-1}). \tag{digital-ui} \end{align}
</p>
<p> In practice, the expansion in ( <a class="el" href="../../d5/d87/namespaceumontreal_1_1ssj_1_1hups.html#REF_hups_overview_eq_digital_uij">digital-uij</a> ) is truncated to the first \(w\) digits for some positive integer \(w\), so each matrix \(\mathbf{C}_j\) is actually truncated to a \(w\times k\) matrix. Typically \(w\) is equal to \(k\), or is slightly larger, or is selected so that \(b^r\) is near or equal to the largest representable integer, e.g., \(2^{31}\) on an 32-bit processor, and perhaps \(2^{53}\) or larger on a 64-bit processor, to take advantage of the precision of floating-point numbers in <code>double</code> for the \(u_{i,j}\)'s.</p>
<p>Usually, the first \(k\) lines of each \(\mathbf{C}_j\) form a nonsingular \(k\times k\) matrix. Then, the \(n\) output values for coordinate \(j\), \(u_{0,j},\dots, u_{n-1,j}\), when truncated to their first \(k\) fractional digits in base \(b\), are a permutation of the numbers \(0, 1/n,\dots, (n-1)/n\). Different coordinates would use different permutations, implemented via the matrices \(\mathbf{C}_j\).</p>
<p>When the first \(k\) lines of \(\mathbf{C}_j\) form the identity and the other lines are zero, the first \(n\) output values are the first \(n\) elements of the van der Corput sequence in base \(b\). If we reverse the order of the columns of that matrix \(\mathbf{C}_j\) (i.e., column \(c\) will contain a one in line \(k-c+1\) and zeros elsewhere, for \(0\le c &lt; k\)), we obtain the output values \(0, 1/n, …, (n-1)/n\) in that order. With a slight abuse of language, we shall call this first matrix (with the identity followed by lines of zeros) the <em>identity</em> and the second one (with the columns in reverse order) the <em>reflected identity</em>. It is customary to take \(\mathbf{C}_0\) as the identity for digital sequences, and often for digital nets as well. But for digital nets (where \(n\) is fixed in advance), one can take \(\mathbf{C}_0\) as the reflected identity instead, then \(\mathbf{C}_1\) as the identity, and so on. That is, the matrix \(\mathbf{C}_j\) for the digital net is taken as the matrix \(\mathbf{C}_{j-1}\) of the digital sequence. The <code>hups</code> package often gives the choice.</p>
<p>For digital sequences, the matrices \(\mathbf{C}_j\) actually have an infinite number of columns, although only the first \(k\) columns are needed to generate the first \(b^k\) points. So in practice, we never need to store more than a finite number of columns at a time. When we need more than \(b^k\) points for the current value of \(k\), we can simply increase \(k\) and add the corresponding columns to the matrices \(\mathbf{C}_j\), assuming that we can compute them.</p>
<p>The classes <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a> and <a class="el" href="../../dd/d0d/classumontreal_1_1ssj_1_1hups_1_1DigitalSequence.html">umontreal.ssj.hups.DigitalSequence</a> implement generic digital nets and sequences. Specific instances are constructed in subclasses of these two classes. In particular, <a class="el" href="../../d3/dd5/classumontreal_1_1ssj_1_1hups_1_1DigitalNetBase2.html">umontreal.ssj.hups.DigitalNetBase2</a> implements digital nets in base 2, which are the most popular because computations in binary arithmetic is generally much faster than in other bases. Among those, we find Sobol sequences and Sobol nets, for instance; see <a class="el" href="../../d6/ddf/classumontreal_1_1ssj_1_1hups_1_1SobolSequence.html">SobolSequence</a>. Polynomial lattice rules (see below) are special cases of digital nets and in practice, to generate the points, we implement them as digital nets.</p>
<h2>Lattice Rules</h2>
<p>An <em>integration lattice</em> is a discrete (but infinite) subset of \(\mathbb{R}^s\) of the form </p><p class="formulaDsp">
\[ L_s = \left\{\mathbf{v}= \sum_{j=1}^s h_j {\mathbf{v}_j} \mbox{ such that each } h_j\in\mathbb{Z}\right\}, \]
</p>
<p> where \(\mathbf{v}_1,…,\mathbf{v}_s \in\mathbb{R}^s\) are linearly independent over \(\mathbb{R}\) and \(\mathbb{Z}^s \subseteq L_s\). This last condition means that \(L_s\) must contain all integer vectors, and this implies that \(L_s\) is periodic with period 1 along each of the \(s\) coordinates. The approximation of \(\mu\) by \(Q_n\) with the point set \(P_n = L_s \cap[0,1)^s\) is called a <em>lattice rule</em> <b>[vHIC98c]</b>, <b>[mKOR59a]</b>, <b>[vLEC00b]</b>, <b>[vSLO94a]</b>. The value of \(n\) is the number of points of the lattice that are in the unit hypercube \([0,1)^s\).</p>
<p>Let \(\mathbf{V}\) be the matrix whose rows are the basis vectors \(\mathbf{v}_1,\cdots,\mathbf{v}_s\) and \(\mathbf{V}^{-1}\) its inverse. One has \(\mathbb{Z}^s\subseteq L_s\) if and only if all entries of \(\mathbf{V}^{-1}\) are integer. When this holds, \(n = \det(\mathbf{V}^{-1})\) and all entries of \(\mathbf{V}\) are multiples of \(1/n\). The <em>rank</em> of the lattice is the smallest \(r\) such that one can find a basis of the form \(\mathbf{v}_1,\dots, \mathbf{v}_r,\mathbf{e}_{r+1},\cdots,\mathbf{e}_s\), where \(\mathbf{e}_j\) is the \(j\)th unit vector in \(s\) dimensions. In particular, a lattice rule of <em>rank 1</em> has a basis of the form \(\mathbf{v}_1 = (a_1, \dots, a_s)/n\) and \(\mathbf{v}_j = \mathbf{e}_j\) for \(j&gt;1\), where \(a_j \in\mathbb{Z}_n\) for each \(j\). Lattice rules of rank 1 are implemented in <a class="el" href="../../d4/d94/classumontreal_1_1ssj_1_1hups_1_1Rank1Lattice.html">Rank1Lattice</a>. The class <a class="el" href="../../dd/d26/classumontreal_1_1ssj_1_1hups_1_1KorobovLattice.html">KorobovLattice</a> implements <em>Korobov</em> lattice rules, which occur when \(\mathbf{v}_1\) has the special form \(\mathbf{v}_1 = (1,\; a,\; a^2 \mod n,\; \dots \; a^{s-1} \mod n)/n\) for some \(a\in\mathbb{Z}_n\). The point set \(P_n\) of a Korobov lattice rule can also be written as \(P_n = \{(x_1,…,x_s)/n \mbox{ such that } x_1\in\mathbb{Z}_n \mbox{ and } x_j = a x_{j-1} \mod n \mbox{ for all } j &gt; 1\}\). This is the set of all vectors of successive values produced by a linear congruential generator (LCG) with modulus \(n\) and multiplier \(a\), from all possible initial states, including 0. In this case, the points are easy to enumerate by using the recurrence, and this is what we do in <a class="el" href="../../da/d7a/classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">LCGPointSet</a>.</p>
<p>Uniformity criteria for lattice rules, and methods and software to search for good parameters \(a_1,\dots, a_s\) for rank 1 lattice rules for any given \(s\) and \(n\) and various types of criteria, can be found in <b>[vLEC12a]</b>, <b>[vLEC12b]</b>, <b>[vLEC16a]</b>, and <b>[rNUY14a]</b>, for example.</p>
<h2>Polynomial Lattice Rules</h2>
<p>Integration lattices defined in a space of polynomials instead of in the real space provide another very effective way of constructing QMC points <b>[vDIC09a]</b>, <b>[rDIC10a]</b>, <b>[rLEC02b]</b>, <b>[vLEC04a]</b>, <b>[vLEC09f]</b>, <b>[vLEM00t]</b>, <b>[vLEM03a]</b>, <b>[rNIE92c]</b>, <b>[rNUY14a]</b>. These lattices are similar to the ordinary integration lattices, but are defined in different spaces. They also turn out to be special cases of digital nets. The following follows <b>[vLEC09f]</b>.</p>
<p>To define a <em>polynomial integration lattice</em>, we first select an integer \(b \geq 2\) called the <em>base</em>, let \(\mathbb{Z}_b\) denote the ring of integers modulo \(b\), \(\mathbb{Z}_b[z]\) the ring of polynomials with coefficients in \(\mathbb{Z}_b\), and \(\mathbb{L}_b\) the ring of formal Laurent series with coefficients in \(\mathbb{Z}_b\), which have the form \(\sum_{\ell=\omega}^\infty x_\ell z^{-\ell}\), where \(x_\ell\in\mathbb{Z}_b\). The lattice is defined as </p><p class="formulaDsp">
\[ \tag{eq:cLs} {\mathcal{L}_s} = \left\{\mathbf{v}(z) = \sum_{j=1}^s q_j(z) \mathbf{v}_j(z) \mbox{ such that each } q_j(z) \in \mathbb{Z}_b[z]\right\}, \]
</p>
<p> where \(\mathbf{v}_j(z) = \mathbf{a}_j(z)/P(z) \in \mathbb{L}_b\) for \(j=1,\dots,s\), \(P(z) = z^k + \alpha_1 z^{k-1} + \cdots + \alpha_k \in \mathbb{Z}_b[z]\), and each \(\mathbf{a}_j(z)\) is a vector of \(s\) polynomials of degree less than \(k\). We have \((\mathbb{Z}_b[z])^s \subseteq \mathcal{L}_s\). The output mapping \(\varphi : \mathbb{L}_b \to \mathbb{R}\) is defined by </p><p class="formulaDsp">
\[ {\varphi}\left(\sum_{\ell=\omega}^\infty x_\ell z^{-\ell}\right) = \sum_{\ell=\omega}^\infty x_\ell b^{-\ell}. \]
</p>
<p> The <em>polynomial lattice rule</em> uses the node set \(P_n = \varphi(\mathcal{L}_s) \cap [0,1)^s = \varphi(\mathcal{L}_s \cap \mathbb{L}_{b,0})\), where \(\mathbb{L}_{b,0} = \mathbb{L}_b\) mod \(\mathbb{Z}_b[z]\). Most properties of ordinary lattice rules have counterparts for the polynomial rules <b>[vDIC08b]</b>, <b>[rDIC10a]</b>, <b>[vLEC04a]</b>, <b>[vLEM03a]</b>, <b>[rNUY14a]</b>.</p>
<p>In SSJ, the polynomial lattice rules are implemented as digital nets, because this provides a faster way to generate the points than working directly in polynomial arithmetic, especially in base \(b = 2\). The user can construct a <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> object from a polynomial lattice rule using .......</p><ul>
<li>...... explain what we have in hups for that.... to be done *</li>
</ul>
<h2>Cycle-based point sets</h2>
<p>Certain types of QMC point sets are defined pretty much like random number generators, in the sense that the successive coordinates of each point follow a simple linear recurrence over a finite state space \(\mathcal{S}\), with a transition function \(f : \mathcal{S}\to\mathcal{S}\), and an output function \(g : \mathcal{S}\to[0,1)\). The point set is defined as </p><p class="formulaDsp">
\[ P_n = \{\mathbf{u}= (u_0,u_1,…) : s_0\in\mathcal{S}, s_j = f(s_{j-1}), \mbox{ and } u_j = g(s_j) \mbox{ for all } j\}. \]
</p>
<p> This is the set of all vectors of successive output values produced by the recurrence defined by \(f\) and the output function \(g\), from all possible initial states. The value of \(n\) is the cardinality of \(\mathcal{S}\) and the dimension \(s\) is infinite. We could also have \(n = \infty\) (an infinite sequence) if \(\mathcal{S}\) is infinite but denumerable and ordered (so we know in which order to enumerate the points).</p>
<p>Let us assume that \(n\) is finite and that for each \(s_0\in\mathcal{S}\), the recurrence \(s_j = f(s_{j-1})\) is <em>purely periodic</em>, i.e., there is always an integer \(j\) such that \(s_j = s_0\). The smallest such \(j\), called the <em>period length</em>, depends in general on \(s_0\). Thus, the state space \(\mathcal{S}\) is partitioned into a finite number of <em>cycles</em>. The successive coordinates of any point \(\mathbf{u}\in P_n\) are periodic with period length equal to the length of the cycle that contains \(s_0\) (and the following \(s_j\)’s).</p>
<p>One way of implementing such a point set while avoiding to recompute \(f\) and \(g\) each time a coordinate is needed is to store explicitly all the cycles of the recurrence, in the form of a <em>list of cycles</em>. We can store either the successive \(u_j\)’s directly, or the successive \(s_j\)’s, over each cycle. The class <a class="el" href="../../d4/d45/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">umontreal.ssj.hups.CycleBasedPointSet</a> provides the framework for doing that. For example, a Korobov lattice point set is defined via the recurrence \(x_j = a x_{j-1} \bmod n\) and output function \(u_j = x_j/n\). If \(n\) is prime and \(a\) is a primitive element modulo \(n\), then there are two cycles: one of period 1 that contains only 0, and the other of period \(n-1\). For more general \(n\) and \(a\), there will be more cycles. The class <a class="el" href="../../da/d7a/classumontreal_1_1ssj_1_1hups_1_1LCGPointSet.html">umontreal.ssj.hups.LCGPointSet</a> constructs this type of point set and stores explicitly the successive values of \(u_j\) over the different cycles.</p>
<p>There are cases where \(n\) is a power of two, say \(n = 2^k\), and where the state \(s_j\) is represented as a \(k\)-bit string. Concrete instances are usually based on linear recurrences modulo 2 and they include the Korobov-type <em>polynomial lattice rules</em> in base 2 <b>[rDIC10a]</b>, <b>[rLEC99a]</b>, <b>[vLEC99a]</b>, <b>[rLEC02b]</b>, <b>[vLEM03a]</b>, <b>[rNUY14a]</b>, <b>[rPAN04a]</b>. In that context, it is often more convenient to store the successive states \(s_j\)’s instead of the successive \(u_j\)’s, over the set of cycles (e.g., if a random digital shift in base 2 is to be applied to randomize the points, it can be performed by applying a bitwise xor directly to \(s_j\)). When generating the coordinates, the \(s_j\)’s can be interpreted as \(2^k\)-bit integers and multiplied by \(2^{-k}\) to produce the output. This is supported by the class <a class="el" href="../../de/d58/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSetBase2.html">umontreal.ssj.hups.CycleBasedPointSetBase2</a>.</p>
<h2>Point set implementations and enumeration tools</h2>
<p>The base class for point sets is the abstract class <a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a>. It has several predefined subclasses. Let \(\mathbf{u}_i = (u_{i,0}, u_{i,1}, \dots, u_{i,s-1})\) be the elements of the point set \(P_n\), for \(i=0,\dots,n-1\) (the point and coordinate indexes both start at 0). The number of points \(n\) and the dimension \(s\) can be finite or infinite. Conceptually, the point set can be viewed as a two-dimensional array whose element \((i,j)\) contains \(u_{i,j}\), the coordinate \(j\) of point \(i\). In the implementations of typical point sets, the values \(u_{i,j}\) are not stored explicitly in a two-dimensional array, but relevant information is organized so that the points and their coordinates can be generated efficiently. One notable exception is <a class="el" href="../../df/d86/classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">umontreal.ssj.hups.CachedPointSet</a>, in which all (randomized) points are stored explicitly. This is required for certain types of randomizations such as stratified sampling and Latin hypercube sampling, for example.</p>
<p>To enumerate the successive points or the successive coordinates of a given point, we use <em>point set iterators</em>, that resemble the iterators defined in Java <em>collections</em>, except that they loop over bi-dimensional sets. Their general behavior is defined in the interface <a class="el" href="../../d7/d29/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a>. It contains methods to traverse a point set. One can return only one coordinate, \(t\) coordinates, change the current coordinate and current point index, reset the iterator, and so on. Several independent iterators can coexist at any given time for the same point set. Each one maintains a current point index and a current coordinate index, which are incremented by 1 when the iterator advances to the next point or to the next coordinate. Both are initialized to 0. Each subclass of <a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html">umontreal.ssj.hups.PointSet</a> has its own implementation of <a class="el" href="../../d7/d29/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> and has a method <code>iterator()</code> that creates and returns a new specialized point set iterator of the correct type, allowing efficient access to the coordinates.</p>
<p>An important feature of the <a class="el" href="../../d7/d29/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetIterator.html">umontreal.ssj.hups.PointSetIterator</a> interface is that it extends the <a class="el" href="../../d1/d7c/interfaceumontreal_1_1ssj_1_1rng_1_1RandomStream.html">umontreal.ssj.rng.RandomStream</a> interface. This means that any point set iterator can be used in place of a random stream that is supposed to generate i.i.d. \(U(0,1)\) random variables, anywhere in a simulation program. This makes it very easy to replace the (pseudo)random numbers by the coordinates \(u_{i,j}\) of a deterministic (or randomized) HUPS without changing the internal code of the simulation program.</p>
<h2>Randomized quasi-Monte Carlo</h2>
<p>In their original versions, these HUPS described so far are deterministic, and the corresponding QMC methods give a <em>deterministic</em> integration error that is difficult to estimate. In <em>randomized</em> QMC methods, \(P_n\) is randomized, preferably in a way that it retains its high uniformity over \([0,1)^s\) when taken as a set, while each of its points has the uniform distribution over \([0,1)^s\) when taken individually. Then, \(Q_n\) becomes an unbiased estimator of \(\mu\), hopefully with smaller variance than the standard MC estimator. To estimate the variance and compute a confidence interval on \(\mu\), one can apply \(m\) independent randomizations to the same \(P_n\), and compute \({\bar{X}_m}\) and \({S_{m,x}^2}\), the sample mean and sample variance of the \(m\) corresponding (independent) copies of \(Q_n\). Then, \(E[\bar{X}_m] = \mu\) and \(E[S_{m,x}^2] = \mathrm{Var}[Q_n] = m\mathrm{Var}[\bar{X}_m]\) <b>[vLEC00b]</b>, <b>[vOWE97a]</b>, <b>[vOWE03a]</b>.</p>
<p>Two examples of such randomizations are the <em>random shift modulo 1</em>, proposed in <b>[vCRA76a]</b> and implemented in class umontreal.ssj.hups.RandShiftedPointSet, and the <em>random digital shift in base \(b\)</em>, described and implemented in class <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">umontreal.ssj.hups.DigitalNet</a>. In the random shift modulo 1, we generate a <em>single</em> point \(\mathbf{u}\) uniformly over \([0,1)^s\) and add it to each point of \(P_n\), coordinate-wise, modulo 1. Since all points of \(P_n\) are shifted by the same amount, the set retains most of its structure and uniformity. For the random digital shift in base \(b\), we generate again a single \(\mathbf{u}= (u_0,\dots,u_{s-1})\) uniformly over \([0,1)^s\), write the digital expansion in base \(b\) of each of its coordinates, say \(u_j = \sum_{\ell=1}^{\infty}d_{j,\ell} b^{-\ell}\), then add \(d_{j,\ell}\) modulo \(b\) to the \(\ell\)th digit of the digital expansion in base \(b\) of the \(j\)th coordinate of each point \(\mathbf{u}_i\in P_n\). For \(b=2\), the digit-wise addition modulo \(b\) becomes a bitwise exclusive-or, which is fast to perform on a computer.</p>
<p>An important property of the digital shift in base \(b\) is that if the hypercube \([0,1)^s\) is partitioned into \(b^{q_1 + \cdots+ q_s}\) rectangular boxes of the same size by partitioning the \(j\)th axis into \(b^{q_j}\) equal parts for each \(j\), for some integers \(q_j \ge0\) (such a partition is called a <em> \(\mathbf{q}\)-equidissection in base \(b\)</em> of the unit hypercube, where \(\mathbf{q}= (q_1,…,q_s)\)), then the number of boxes that contain \(m\) points, for each integer \(m\), is unchanged by the randomization. In particular, if each box contains the same number of points of \(P_n\) before the randomization, then it also does after the randomization. In this case, we say that \(P_n\) is <em> \(\mathbf{q}\)-equidistributed in base \(b\)</em>. Several other randomization methods exist and most are adapted to special types of point sets; for example they randomize the generator matrices of a digital net <b>[vOWE03a]</b>.</p>
<p>In the <code>hups</code> package, viewed from the outside, randomization methods for QMC point sets are defined in classes that implement the <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">umontreal.ssj.hups.PointSetRandomization</a> interface. Each subclass of <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> defines a type of randomization. By combining a <a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html">PointSet</a> object with a <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> object, one can obtain an <a class="el" href="../../dd/d7b/classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html">umontreal.ssj.hups.RQMCPointSet</a> object. However, not every type of randomization is compatible with a given type of point set. For example, a umontreal.ssj.hups.LMSScrambleShift and a <a class="el" href="../../d4/d42/classumontreal_1_1ssj_1_1hups_1_1NestedUniformScrambling.html">umontreal.ssj.hups.NestedUniformScrambling</a> apply only to <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> point sets. The usual (and recommended) way of doing RQMC in SSJ is to construct a <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> and a compatible <code><a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is for a randomization that can be used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code>, combine them into an <code><a class="el" href="../../dd/d7b/classumontreal_1_1ssj_1_1hups_1_1RQMCPointSet.html" title="This class is used for randomized quasi-Monte Carlo (RQMC) simulations , , , . ">RQMCPointSet</a></code>, and use the latter to run RQMC experiments. The class umontreal.ssj.hups.RQMCExperiments offers some methods that can perform such experiments for simple Monte Carlo models. Examples are given in the tutorial.</p>
<p>Conceptually, one could think of the <code><a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is for a randomization that can be used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> objects as filters that transform all the QMC points \(\mathbf{u}_i\) after they have been computed. However, almost all randomizations are not implemented that way, but they are incorporated directly in the calculation of the points \(\mathbf{u}_i\) by the point set iterators in the <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> subclasses, mainly for reasons of efficiency. In fact, the <code>randomize</code> method of a <code><a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is for a randomization that can be used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> applied to a <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object <code>p</code> can only impact the point set <code>p</code>, which means that the randomization must be incorporated in <code>p</code> in some way. For example, a randomization that changes the generator matrices of a <code><a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html" title="This class provides the basic structures for storing and manipulating linear digital nets in base ...">DigitalNet</a></code> is implemented by changing directly those generator matrices in the <code><a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html" title="This class provides the basic structures for storing and manipulating linear digital nets in base ...">DigitalNet</a></code> object before generating the point. The old matrices are saved so we can revert the change. The random shifts and digital random shifts are also applied directly inside the <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object when the points are generated. Each <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> has a method <code>addRandomShift</code> that takes a <code>RandomStream</code> and generates a random shift to be applied to all the points. Depending on the type of point set, it can be either a digital shift or a shift modulo 1. This must be specified and defined inside each subclass of <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code>. By default, for all <a class="el" href="../../de/d70/classumontreal_1_1ssj_1_1hups_1_1DigitalNet.html">DigitalNet</a> point sets, this random shift is a <em>random digital shift</em>, whereas for ordinary lattice rules it is a <em>random shift modulo 1</em>. For any given type of point set, one should check the documention to make sure what the <code>addRandomShift</code> method really does. A <a class="el" href="../../dc/db7/classumontreal_1_1ssj_1_1hups_1_1RandomShift.html">umontreal.ssj.hups.RandomShift</a> is a type of randomization that invokes directly this internal <code>addRandomShift</code> facility.</p>
<p>One complication arises in the case of point sets having an unbounded number of coordinates; for example, a <a class="el" href="../../d4/d45/classumontreal_1_1ssj_1_1hups_1_1CycleBasedPointSet.html">CycleBasedPointSet</a>, whose points have a infinite number of coordinates. In this case, the random shift must be generated for a finite number of coordinates, but it can always be extended later if we need more (randomized) coordinates for any given point. This is one of the main reasons for having a version of the <code>addRandomShift</code> method that generates the random shift only over an arbitrary range of coordinates, say from <code>d1</code> to <code>d2-1</code>. It can be used to <em>extend</em> the current random shift if needed. This extension will usually be performed automatically by the iterator, using the same <code>RandomStream</code> that was used to produce the previous random shift (this stream is saved internally for this purpose).</p>
<p>We recommend to always use a <code><a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html" title="This interface is for a randomization that can be used to randomize a umontreal.ssj.hups.PointSet. ">PointSetRandomization</a></code> object (such as a <code><a class="el" href="../../dc/db7/classumontreal_1_1ssj_1_1hups_1_1RandomShift.html" title="This class implements a umontreal.ssj.hups.PointSetRandomization. ">RandomShift</a></code>) and use its <code>randomize (<a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a> p)</code> method rather than calling <code>addRandomShift</code> directly, because this permits one to change the randomization externally without changing the <code>randomize</code> call internally in a simulation program. The tutorial and the code of some methods in umontreal.ssj.hups.RQMCExperiments provide examples of that.</p>
<p>With the current implementation, in which the randomizations are integrated in the <code><a class="el" href="../../d8/d10/classumontreal_1_1ssj_1_1hups_1_1PointSet.html" title="This abstract class represents a general point set. ">PointSet</a></code> object itself and not in the iterator, different iterators operating in parallel on the same point set will all eumerate the same randomized points when the points are randomized. To have independent randomizations for the different iterators, the randomizations would have to be implemented in the iterators. Currently, to use different randomizations of the same point set in parallel, one can simply construct many instances of the same point set and randomize them independently.</p>
<h2>Transformed point sets and containers</h2>
<p>Aside from the <a class="el" href="../../d7/d98/interfaceumontreal_1_1ssj_1_1hups_1_1PointSetRandomization.html">PointSetRandomization</a> subclasses, the <code>hups</code> package also offers tools to transform arbitrary point sets in various ways, either deterministically or randomly, by external filters. Some deterministic transformations can be applied to eliminate some points or coordinates (i.e., selecting subsets), or to concatenate point sets (padding), or to take an antithetic version of a point set, for example. Some types of random transformations can be used for RQMC. When a point set is transformed, we usually want to keep the original as well, and we may want to apply different types of transformations in succession to the same point set.</p>
<p>This is achieved via <em>container</em> point sets, which are defined in terms of another point set to which they keep a reference and apply certain transformations. <a class="el" href="../../d4/d02/classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html">umontreal.ssj.hups.ContainerPointSet</a> is the base class for such containers. The contained point set can be a container itself and this can be done recursively, but many levels of recursivity can obviously slow down the generation of the points.</p>
<p>One example of a <code><a class="el" href="../../d4/d02/classumontreal_1_1ssj_1_1hups_1_1ContainerPointSet.html" title="This acts as a generic base class for all container classes that contain a point set and apply a spec...">ContainerPointSet</a></code> that performs a randomization is a <a class="el" href="../../db/df7/classumontreal_1_1ssj_1_1hups_1_1RandShiftedMod1PointSet.html">umontreal.ssj.hups.RandShiftedMod1PointSet</a>, which applies a random shift modulo 1 to the point set that it contains, whatever it is. It can be used for instance if one wishes to apply a random shift modulo 1 to a <code>Digitalnet</code>. Another one is <a class="el" href="../../dc/d3d/classumontreal_1_1ssj_1_1hups_1_1AntitheticPointSet.html">umontreal.ssj.hups.AntitheticPointSet</a>, which permits one to generate the antithetic coordinates for any given point set, i.e., return \(1-u_{i,j}\) instead of \(u_{i,j}\). A third example is a <a class="el" href="../../db/d5e/classumontreal_1_1ssj_1_1hups_1_1BakerTransformedPointSet.html">umontreal.ssj.hups.BakerTransformedPointSet</a>, which applies the baker (or tent) transformation to the contained points. Such container point sets implement their own iterators that use the iterators of the contained point sets to access the points almost as efficiently as if the contained point set iterators were used directly, and they add their transformation.</p>
<p>The <a class="el" href="../../d9/d1f/classumontreal_1_1ssj_1_1hups_1_1SubsetOfPointSet.html">umontreal.ssj.hups.SubsetOfPointSet</a> allows one to constrain a point set’s size or dimension, for example to limit the dimension of a cycle-based point set to a finite integer \(s\). The class <a class="el" href="../../d4/d88/classumontreal_1_1ssj_1_1hups_1_1PaddedPointSet.html">umontreal.ssj.hups.PaddedPointSet</a> gathers two or more point sets of the same cardinality and juxtaposes (pads) them to construct a point set whose dimension is the sum of dimensions of the padded components.</p>
<h2>Cached points for stratified sampling, Latin hypercube sampling, sorted points, etc.</h2>
<p>In the class <a class="el" href="../../df/d86/classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html">umontreal.ssj.hups.CachedPointSet</a>, all coordinates of all the points are stored internally in a matrix, and can then be accessed very efficiently. Storing the points explicitly like this is necessary for certain types of point sets or sampling, for which the points cannot be recovered from a smaller amount of information. One trivial example of this is a set of \(n\) independent random points, which is implemented in <a class="el" href="../../d4/d8b/classumontreal_1_1ssj_1_1hups_1_1IndependentPointsCached.html">umontreal.ssj.hups.IndependentPointsCached</a>. This implementation can be useful in case one has a program to simulate a system with RQMC points and one wishes to try it with independent points for comparizon.</p>
<p>Stratified sampling over the unit cube can be implemented as follows. One partitions the unit cube in \(n\) rectangles of the same size and one generates one point in each rectangle, uniformly and independently across rectangles. The class <a class="el" href="../../d2/dcf/classumontreal_1_1ssj_1_1hups_1_1StratifiedUnitCube.html">umontreal.ssj.hups.StratifiedUnitCube</a> implements this. Here, the randomized points must be stored explicitly, so this is implemented as a subclass of <code><a class="el" href="../../df/d86/classumontreal_1_1ssj_1_1hups_1_1CachedPointSet.html" title="This container class caches a point set by precomputing and storing its points locally in an array...">CachedPointSet</a></code>. Another subclass is <a class="el" href="../../dc/d02/classumontreal_1_1ssj_1_1hups_1_1LatinHypercube.html">umontreal.ssj.hups.LatinHypercube</a>, which implements <em>Latin hypercube sampling.</em> Yet another one is <a class="el" href="../../de/dab/classumontreal_1_1ssj_1_1hups_1_1SortedAndCutPointSet.html">umontreal.ssj.hups.SortedAndCutPointSet</a>, in which the inner points are sorted by the first few (one or more) coordinates, then these coordinates are removed and the other ones are cached in their new order. These types of constructions are used in the Array-RQMC method <b>[vLEC08a]</b>, <b>[vLEC16b]</b>.</p>
<h2>Examples</h2>
<p>See the tutorial. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
