<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SSJ User&#39;s Guide.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ssj.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">Stochastic Simulation in Java</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">SSJ User's Guide. </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="REF_0_sec_01"></a>
Introduction and overview</h1>
<p>SSJ (Stochastic Simulation in Java) is a Java library offering tools for stochastic (Monte Carlo) simulation <b>[sASM07a]</b>, <b>[sLAW14a]</b>. It provides basic facilities for random number generation with multiple streams and substreams, implements univariate and multivariate probability distributions and variate generators for them, functions to simulate certain types of stochastic processes, efficient event-list management tools for discrete-event simulation, support for an extensive collection of randomized quasi-Monte Carlo methods, statistical probes to collect data from simulation experiments, statistical estimation and goodness-of-fit methods, some tools to produce plots in LaTeX, and various other classes and methods that can be useful for simulation.</p>
<p>These tools are organized in a powerful and flexible system (or framework) of packages and classes. SSJ can be used to write simulation programs for stochastic models of various types of real-life systems, simple or very complex. It is also appropriate for implementing Monte Carlo methods for various types of applications.</p>
<p>For discrete-event simulation, commercial tools with drag-and-drop graphical interfaces such as <em>AnyLogic</em>, <em>Arena</em>, <em>Automod</em>, <em>ProModel</em>, <em>Simio</em>, <em>Simul8</em>, <em>Witness</em>, and many others, are widely used. Among their advantages, these tools do not require knowledge of a programming language, provide graphical animation, have automatic facilities to collect statistics and perform experiments, and can sometimes perform optimization to a certain extent. On the other hand, they are often too restrictive, because they are targeted at specific classes of models. With these tools, simulating a system whose logic is complicated or unconventional may become difficult. The graphical and automatic devices also tend to slow down the simulation significantly. Fast execution times are important for example in a context of optimization, where thousands of variants of a base system may have to be simulated, or for on-line applications where a fast response time is required.</p>
<p>SSJ, on the other hand, is very flexible and designed to facilitate efficient simulation modeling and programming in the Java language. A first version was described in <b>[sLEC02a]</b> and <b>[sLEC05a]</b>&thinsp;. It is growing actively: new packages, classes, and methods are added regularly. It can be used freely by anyone and the source code is also freely available.</p>
<p>The facilities offered are grouped into different packages that are connected to each other. All the packages and classes have a detailed documentation produced by Doxygen. One may also want to look at the old .pdf manuals available at <a href="http://www-labs.iro.umontreal.ca/~simul/ssj-2/doc/pdf/">Old pdf doc</a>; they are out of date but contains more detailed explanations in some parts. (A detailed <code>.pdf</code> manual will be available in the future.)</p>
<p>There is also a tutorial guide that contains a set of commented-out examples of simulation programs, together with the Java code (see the Documentation section below). Some of these examples are taken from books such as <b>[sLAW14a]</b> and <b>[fGLA04a]</b>, for example. The best way to start learning SSJ is to study these examples and refer to the online detailed documentation when needed.</p>
<p>The packages currently offered are the following.</p>
<p><b>Probability distributions, random number and random variate generation, and quasi-Monte Carlo:</b></p>
<p><a class="el" href="d1/db6/namespaceumontreal_1_1ssj_1_1probdist.html">umontreal.ssj.probdist</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, and inverse distribution functions for many discrete and continuous probability distributions, as well as estimating the parameters of these distributions from given data.</p>
<p><a class="el" href="d9/d48/namespaceumontreal_1_1ssj_1_1probdistmulti.html">umontreal.ssj.probdistmulti</a> contains a set of Java classes providing methods to compute mass, density, distribution, complementary distribution, for some multi-dimensionnal discrete and continuous probability distributions.</p>
<p><a class="el" href="dd/dcd/namespaceumontreal_1_1ssj_1_1rng.html">umontreal.ssj.rng</a> provides facilities for generating uniform random numbers over the interval \((0,1)\), or over a given range of integer values, and other types of simple random objects such as random permutations. The basic type of object here is a <em>stream</em> of random numbers.</p>
<p><a class="el" href="d5/d64/namespaceumontreal_1_1ssj_1_1randvar.html">umontreal.ssj.randvar</a> provides a collection of classes for non-uniform random variate generation, primarily from standard distributions.</p>
<p><a class="el" href="d1/d96/namespaceumontreal_1_1ssj_1_1randvarmulti.html">umontreal.ssj.randvarmulti</a> provides a collection of classes for random number generators for some multi-dimensional distributions.</p>
<p><a class="el" href="d4/dfc/namespaceumontreal_1_1ssj_1_1stochprocess.html">umontreal.ssj.stochprocess</a> implements various kinds of stochastic processes and methods to generate their sample paths.</p>
<p><b>Tools for quasi-Monte Carlo:</b></p>
<p><a class="el" href="d5/d87/namespaceumontreal_1_1ssj_1_1hups.html">umontreal.ssj.hups</a> provides classes implementing highly uniform point sets and sequences (HUPS), also called low-discrepancy sets and sequences, used for quasi-Monte Carlo methods, and tools for their randomization (for randomized quasi-Monte Carlo).</p>
<p><a class="el" href="dd/d4a/namespaceumontreal_1_1ssj_1_1latnetbuilder.html">umontreal.ssj.latnetbuilder</a> is an interface to the LatNet Builder software to constructs quasi-Monte Carlo point sets and sequences of various types (lattices, polynomial lattices, digital nets, etc.) for arbitrary dimension and cardinality, various uniformity criteria, etc.</p>
<p><b>Statistical tools:</b></p>
<p><a class="el" href="d3/d47/namespaceumontreal_1_1ssj_1_1stat.html">umontreal.ssj.stat</a> provides elementary tools for collecting statistics and computing confidence intervals.</p>
<p><a class="el" href="d5/d95/namespaceumontreal_1_1ssj_1_1stat_1_1matrix.html">umontreal.ssj.stat.matrix</a> this subpackage of <code>stat</code> provides facilities to create and manage rectangular two-dimensional arrays of statistical collectors.</p>
<p><a class="el" href="d0/dee/namespaceumontreal_1_1ssj_1_1stat_1_1list.html">umontreal.ssj.stat.list</a> this subpackage of <code>stat</code> provides support to manage lists of statistical collectors.</p>
<p><a class="el" href="d8/da3/namespaceumontreal_1_1ssj_1_1stat_1_1list_1_1lincv.html">umontreal.ssj.stat.list.lincv</a> this subpackage of <code>stat.list</code> provides classes that help implement control variables on lists of collectors.</p>
<p><a class="el" href="d0/d11/namespaceumontreal_1_1ssj_1_1gof.html">umontreal.ssj.gof</a> contains tools for performing univariate goodness-of-fit (GOF) statistical tests.</p>
<p><a class="el" href="dd/d0b/namespaceumontreal_1_1ssj_1_1stat_1_1density.html">umontreal.ssj.stat.density</a> offers tools to construct histograms and estimate densities from data.</p>
<p><b>Discrete-event simulation:</b></p>
<p><a class="el" href="d6/db8/namespaceumontreal_1_1ssj_1_1simevents.html">umontreal.ssj.simevents</a> provides and manages the event-driven simulation facilities as well as the simulation clock. Can manage several simulations in parallel, in the same program.</p>
<p><a class="el" href="da/d0b/namespaceumontreal_1_1ssj_1_1simevents_1_1eventlist.html">umontreal.ssj.simevents.eventlist</a> this subpackage of <code>simevents</code> offers several kinds of event list implementations.</p>
<p><b>Simulation experiments with MC and RQMC:</b></p>
<p><a class="el" href="d6/d39/namespaceumontreal_1_1ssj_1_1charts.html">umontreal.ssj.charts</a> provides tools for construction, visualization, and customization of \(x--y\) plots, histograms, and empirical styled charts from a Java program.</p>
<p><a class="el" href="d9/de0/namespaceumontreal_1_1ssj_1_1simexp.html">umontreal.ssj.simexp</a> provides facilities for performing simulation experiments using independent replications as well as simulations using batch means.</p>
<p><a class="el" href="d6/db8/namespaceumontreal_1_1ssj_1_1mcqmctools.html">umontreal.ssj.mcqmctools</a> offers some predefined methods to perform Monte Carlo and (randomized) quasi-Monte Carlo experiments.</p>
<p><a class="el" href="d9/d4f/namespaceumontreal_1_1ssj_1_1mcqmctools_1_1anova.html">umontreal.ssj.mcqmctools.anova</a> provides methods to estimate ANOVA components for Monte Carlo models.</p>
<p><a class="el" href="de/dc4/namespaceumontreal_1_1ssj_1_1markovchainrqmc.html">umontreal.ssj.markovchainrqmc</a> contains classes designed for Markov chain simulation using randomized quasi-Monte Carlo, e.g., via Array-RQMC.</p>
<p><b>Other:</b></p>
<p><a class="el" href="d3/da5/namespaceumontreal_1_1ssj_1_1splitting.html">umontreal.ssj.splitting</a> provides implementation of splitting algorithms (Generalized Splitting). For the moment, they can only be applied to networks.</p>
<p><a class="el" href="d5/dd2/namespaceumontreal_1_1ssj_1_1networks.html">umontreal.ssj.networks</a> provides graph data structures suited to rare-event probabilities estimation, with the possibility of adding dependencies between edges/nodes, implementation of classic static reliability algorithms(Permutation Monte Carlo, Turnip) and their variants, and various useful tools (samplers, Markov Chains)</p>
<p><b>General utilities:</b></p>
<p><a class="el" href="d7/db3/namespaceumontreal_1_1ssj_1_1util.html">umontreal.ssj.util</a> contains basic utility classes used in the implementation of SSJ, and which can be useful elsewhere. For example, there are timers (for CPU usage), utilities to read or format numbers and arrays from/to text, operations on binary vectors and matrices, some mathematical functions and constants, root-finding tools, and so on.</p>
<p><a class="el" href="da/dba/namespaceumontreal_1_1ssj_1_1util_1_1sort.html">umontreal.ssj.util.sort</a> contains utility classes to sort multi-dimensional points. This is useful for Array-RQMC, for example.</p>
<p><a class="el" href="d1/d5e/namespaceumontreal_1_1ssj_1_1functions.html">umontreal.ssj.functions</a> implements certain functions that can be passed as objects.</p>
<p><a class="el" href="d9/dc5/namespaceumontreal_1_1ssj_1_1functionfit.html">umontreal.ssj.functionfit</a> implements some elementary function approximation methods such as polynomial interpolation, splines, linear regression, etc.</p>
<h1><a class="anchor" id="REF_0_sec_02"></a>
Dependence on other libraries</h1>
<p>The following free third-party Java libraries are used in the implementation of some SSJ classes. See the SSJ installation instructions for how to install them on your computer.</p>
<p>The <a href="http://acs.lbl.gov/software/colt/">Colt library</a> , developed at the Centre Européen de Recherche Nucléaire (CERN) in Geneva <b>[iHOS04a]</b>&thinsp;, is a large library that provides a wide range of facilities for high performance scientific and technical computing in Java. SSJ uses the class DoubleArrayList from Colt in a few of its classes, namely in packages <a class="el" href="d3/d47/namespaceumontreal_1_1ssj_1_1stat.html">umontreal.ssj.stat</a> and <a class="el" href="d5/d87/namespaceumontreal_1_1ssj_1_1hups.html">umontreal.ssj.hups</a>. The reason is that this class provides a very efficient and convenient implementation of an (automatically) extensible array of <code>double</code>, together with several methods for computing statistics for the observations stored in the array (see, e.g., <code>Descriptive</code>). Using Colt was more efficient than using what was available in Java, at least when we decided to do that around 2002. The Colt library is distributed with the SSJ package as <b>colt.jar</b>.</p>
<p>The optimization package of Steve Verrill includes Java translations of the <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Minpack_f77.html">MINPACK</a> routines <b>[iMOR80a]</b>&thinsp; for nonlinear least squares problems as well as <a href="http://simul.iro.umontreal.ca/Uncmin_f77/Uncmin_f77.html">UNCMIN</a> routines <b>[iSCHa]</b>&thinsp; for unconstrained optimization. They were translated from Fortran to Java by Steve Verrill at the USDA Forest Products Laboratory Madison, Wisconsin, USA, and are in the public domain. They are included in the SSJ distribution as the <b>optimization.jar</b> archive. It is used only in <a class="el" href="d1/db6/namespaceumontreal_1_1ssj_1_1probdist.html">umontreal.ssj.probdist</a> to compute maximum likelihood estimators. This archive also contains the <b>linear_algebra</b> library, based on public domain LINPACK routines, also translated from Fortran to Java by Steve Verrill.</p>
<p><a href="http://www.jfree.org/jfreechart/index.html">JFreeChart</a> is a free Java library that can generate a wide variety of charts and plots for use in applications, applets and servlets. <b>JFreeChart</b> currently supports, amongst others, bar charts, pie charts, line charts, XY-plots, histograms, scatter plots and time series plots. It is distributed with SSJ as <b>jfreechart-*.jar</b>. <a href="http://www.jfree.org/jcommon/index.php">JCommon</a> is a free general purpose Java library containing many useful classes used by JFreeChart and other Java packages. It is distributed with SSJ as <b>jcommon-*.jar</b>. JFreeChart (and JCommon) are used in the SSJ package <b>charts</b> to create different kinds of charts.</p>
<p>SSJ provides an interface to the <a href="http://statistik.wu-wien.ac.at/unuran/">UNURAN</a> library for nonuniform random number generation <b>[iLEY02a]</b>&thinsp;, in the <a class="el" href="d5/d64/namespaceumontreal_1_1ssj_1_1randvar.html">umontreal.ssj.randvar</a> package. UNURAN does not have to be installed to be used with SSJ, because it is linked statically with the appropriate SSJ native library. However, the UNURAN documentation will be required to take full advantage of the library.</p>
<p>The package <a class="el" href="dd/d4a/namespaceumontreal_1_1ssj_1_1latnetbuilder.html">umontreal.ssj.latnetbuilder</a> provides an interface to <a href="http://umontreal-simul.github.io/latnetbuilder/">LatNet Builder</a> which is a C++ library and tool to construct highly-uniform point sets such as lattice rules, polynomial lattice rules, and digital nets in base 2. LatNet Builder must be installed to be able to use this package.</p>
<h1><a class="anchor" id="REF_0_sec_04"></a>
Documentation</h1>
<p>The tutorial available in the scr/main/docs/examples/tutorial directory of this distribution is the best starting point to learn SSJ. It can be accessed by clicking "SSJ Introduction and Tutorial by Examples" in the "Related Pages" section of this Git distribution.</p>
<p>Every package introduced here contains its own reference documentation as a PDF file, in the <code>doc/pdf</code> subdirectory. This documentation describes in more details how to use the package and provides a description of each class and method.</p>
<h1><a class="anchor" id="ssj_acknowledgments"></a>
Acknowledgments</h1>
<p>SSJ was designed and implemented under the supervision of Pierre L’Ecuyer. A first version was released around 2001. The following people (by alphabetic order) have contributed significantly to SSJ:</p>
<p>Mathieu Bague, Sylvain Bonnet, Éric Buist, Wyean Chan, Maxime Dion, Yves Edel, Regina H. S. Hong, Alexander Keller, Pierre L'Ecuyer, Étienne Marcotte, Lakhdar Meliani, David Munger, François Panneton, Florian Puchhammer, Jean-Sebastien Parent-Chartier, Richard Simard, Clément Teule, Mamadou Thiongane, Pierre-Alexandre Tremblay, Jean Vaucher.</p>
<p>The development of SSJ has been supported by NSERC-Canada grant No. ODGP0110050, NATEQ-Québec grant No. 02ER3218, a Killam fellowship, and a Canada Research Chair to P. L'Ecuyer. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
